# 一、实验目的
1. 通过五子棋AI开发，深入理解Minimax算法与Alpha-Beta剪枝技术在零和博弈场景中的应用逻辑与优化价值。
2. 深化对C语言二维数组、结构体、枚举类型及递归函数的理解与实践，提升复杂状态空间的建模与处理能力。
3. 掌握"需求分析-算法设计-GUI实现-测试优化"的完整交互式应用开发流程，熟悉Raylib图形库的基础使用方法，强化结构化编程与模块化设计思维。
4. 通过设计棋盘局势评估函数，掌握模糊博弈状态的量化方法，提升逻辑抽象能力与算法调优技巧。
5. 培养问题分析、独立代码调试、技术文档撰写及模块化编程能力，为复杂系统开发奠定工程实践基础。
# 二、实验环境
## 1. 硬件环境
- CPU型号：Intel(R) Core(TM) i9-14900HX
- 内存大小：32GB
- 存储介质及容量：2TB SSD
- 其他硬件：NVIDIA GeForce RTX 4070 Laptop GPU（独立显卡）
## 2. 软件环境
- 操作系统：Windows 11
- 编译工具：JetBrains CLion
- 调试工具：IDE自带调试器
- 其他辅助软件：Git
# 三、实验原理
五子棋人机对战系统的核心是实现计算机自主决策，整体流程涵盖棋盘状态存储、局势评估、博弈树搜索与图形交互四大核心环节。结合C语言特性，各环节实现原理如下：
1. 棋盘状态存储：采用int类型二维数组`board[SIZE][SIZE]`表示15×15规格棋盘，通过数值编码区分状态：-1表示空位，0表示玩家棋子，1表示AI棋子。数组索引`[row][col]`对应棋盘网格坐标，其中row（行）与col（列）的取值范围均为[0,14]的整数。
2. 局势评估：五子棋对弈过程可抽象为博弈树的动态展开过程，树中每个节点对应一种棋盘局势。评估函数`evaluate_board`负责将局势量化为具体评分并赋值给博弈树叶节点，评分规则定义为：正值表示AI占优，负值表示玩家占优。
3. 博弈树搜索：结合实验设备算力限制，设定搜索深度宏常量`SEARCH_DEPTH=3`，采用Minimax算法进行深度优先搜索。算法角色定义为：AI作为Maximizer（最大化者），目标是最大化每轮评分；玩家作为Minimizer（最小化者），目标是最小化每轮评分。引入Alpha-Beta剪枝技术优化搜索效率，通过`get_best_move`函数求解AI最优落子点。
4. 图形交互：基于Raylib第三方图形库实现，核心是坐标转换机制。通过`PositionToCoordinate`函数完成屏幕像素坐标到棋盘网格坐标的映射，实现玩家落子交互；通过逆向转换逻辑实现网格坐标到像素坐标的映射，完成棋子绘制。
# 四、实验内容与步骤
## 1. 实验内容
设计并实现具备图形界面的五子棋人机对战程序，核心功能如下：
- 对弈逻辑：实现标准五子棋规则，黑棋先手，双方轮流落子，禁止棋盘外及已有棋子位置落子。
- AI决策：AI具备局势评估与最优落子点求解能力，具备基础的攻防策略。
- 游戏结束判定：支持五连子胜利与棋盘满局平局两种终止条件，终止时弹窗提示结果并禁止后续落子。
- 图形交互：加载高清棋盘与棋子素材，实现鼠标悬停预览、最新落子高光提示、非法落子警告及AI思考状态提示等交互功能。
## 2. 实验步骤
### 步骤1：实验准备
1. 需求分析与模块划分：明确核心功能后，将系统拆解为评估、搜索、交互三大模块，绘制系统功能结构图。
2. 开发环境配置：完成Raylib库配置，准备棋盘、棋子、高光提示等高清素材资源。
3. 基础定义与知识储备：学习五子棋棋局知识，定义核心宏常量（含连子评分、棋盘大小、搜索深度等）。
### 步骤2：实验设计
1. 结构体设计：定义`struct Move`结构体描述落子信息，包含落子后局势评分`score`及网格坐标`x`（列）、`y`（行）。
2. 枚举常量设计：定义`typedef enum {STATE_PLAYER_TURN, STATE_AI_TURN, STATE_GAME_OVER} GameState`，用于标识当前回合归属（玩家/AI）及游戏结束状态。
3. 功能函数设计：
    - 评估模块：`evaluate_board()`（计算棋盘局势总评分），依赖`get_pattern_score()`（连子情况与评分映射）和`evaluate_direction()`（多方向连子计数与评分）两个子函数；
    - 搜索模块：`minimax_alpha_beta()`（带Alpha-Beta剪枝的Minimax递归搜索核心算法）、`get_best_move()`（调用搜索算法求解AI最优落子点，返回Move结构体）；
    - 交互模块：`PositionToCoordinate()`（屏幕像素坐标→棋盘网格坐标）、`CoordinateToPosition()`（棋盘网格坐标→屏幕像素坐标）；
    - 结束判定：`is_game_over()`（检测棋盘满局或五连子状态，返回游戏是否结束）。
4. 主界面设计：采用标准棋盘样式，实现鼠标悬停半透明预览棋子、最新落子高光标记、非法落子文本警告及游戏结束后禁止落子的交互逻辑。
### 步骤3：核心模块分析与代码编写
#### 3.1 评估模块（evaluate.h/evaluate.c）
- 评分宏常量定义：
```c  
#define SCORE_FIVE          100000000  // 连五（胜利）  
#define SCORE_LIVE_FOUR     1000000    // 活四  
#define SCORE_BLOCKED_FOUR  100000     // 冲四/堵四  
#define SCORE_LIVE_THREE    10000      // 活三  
#define SCORE_BLOCKED_THREE 1000       // 眠三  
#define SCORE_LIVE_TWO      100        // 活二  
#define SCORE_BLOCKED_TWO   10         // 眠二  
#define SCORE_LIVE_ONE      1          // 活一  
#define SCORE_BLOCKED_ONE   0          // 眠一  
```  
- 评分映射函数`get_pattern_score()`：接收连子数量`count`与两端空闲数`open_ends`两个参数，直接映射为对应评分并返回。
- 连子计数函数`evaluate_direction()`：以指定棋子为起点，通过"行列移动数"（`dr`/`dc`）定义检测方向（纵向：dr=0,dc=1；横向：dr=1,dc=0；左上到右下：dr=1,dc=1；右上到左下：dr=1,dc=-1），统计目标方向连子情况（`count`/`open_ends`），调用`get_pattern_score()`获取评分后返回。
- 局势评分函数`evaluate_board()`：接收整个棋盘为参数，调用`evaluate_direction()`分别计算玩家与AI的各方向连子总评分，定义局势评分为`ai_score - player_score`并返回，作为搜索模块的核心决策依据。
#### 3.2 搜索模块（search.h/search.c）
- Move结构体定义：
```c  
typedef struct {  
    int score;  // 落子后局势评分  
    int x;      // 落子点网格横坐标（列）  
    int y;      // 落子点网格纵坐标（行）  
} Move;  
```  

- 核心搜索算法`minimax_alpha_beta()`：设定搜索深度为3，以当前棋盘为起点，遍历后续`SEARCH_DEPTH`回合内所有可能落子，形成博弈树。通过递归遍历至叶节点，调用`evaluate_board()`获取局势评分，按Minimax规则（Maximizer/Minimizer交替）将评分反向传递至根节点。采用"模拟落子-评分计算-取消落子"的回溯逻辑实现棋局预测，通过Alpha-Beta剪枝优化搜索效率。当搜索深度为0或游戏结束时，直接返回局势评分。
- 最优落子求解`get_best_move()`：作为AI与对弈逻辑的交互接口，遍历棋盘所有空位，通过"模拟落子-调用`minimax_alpha_beta()`评分-取消落子"的流程，筛选出评分最大的落子点（AI为Maximizer），封装为Move结构体返回，其坐标用于GUI模块的AI落子绘制。
#### 3.3 交互模块核心逻辑（GUI.h/GUI.c、evaluate.h）
- 基础架构：引入Raylib图形库构建交互框架。
- 像素坐标→网格坐标：`PositionToCoordinate()`。由于棋盘数组仅支持网格坐标存储，而Raylib获取的鼠标位置为屏幕像素坐标，需通过以下逻辑转换：先通过棋盘素材确定边界像素宽度`marginWidth`与格子像素宽度`cellSideLength`，将鼠标像素坐标减去`marginWidth`后除以`cellSideLength`，得到的浮点数经四舍五入转换为整数，即为对应的棋盘网格行列坐标。

- 网格坐标→像素坐标：`CoordinateToPosition()`。作为上一函数的逆运算，将棋盘网格坐标转换为屏幕像素坐标，用于棋子绘制（Raylib绘图函数仅支持像素坐标），核心逻辑为逆向执行像素→网格的转换过程，并补充棋子纹理居中偏移修正。

- 游戏结束判定：
    - 核心函数`is_game_over()`：遍历棋盘，检测是否存在五连子（逻辑与`evaluate_direction()`类似）或棋盘满局，是则返回1（游戏结束），否则返回0；
    - 胜负判定与展示：在GUI主循环中，通过`GameState`枚举判断当前回合：若游戏结束前为AI回合，则玩家获胜，显示"Player Wins!"；若为玩家回合，则AI获胜，显示"AI wins!"；棋盘满局则显示"Draw!"，同时通过`is_game_over()`返回值阻止后续落子。
#### 3.4 交互模块其他功能设计

- 幽灵棋子预览：根据鼠标悬停位置绘制半透明棋子，直观提示落子位置。

- 最新落子高光：通过高光纹理标记AI或玩家的最新落子点，辅助观察对局节奏。

- 状态提示：实现"AI is thinking"思考提示、非法落子警告等文本提示功能。

*各个函数各自的实现逻辑流程图位于附录。*

**各个模块之间的交互如以下流程图所示：**  
![main函数逻辑](project/report/main函数逻辑.drawio.png)

### 步骤4：实验测试

实验测试分为基础功能测试与对弈策略测试两类：

#### 基础功能测试

- 数组边界稳定性：测试棋盘边缘落子场景，验证程序是否存在崩溃或异常。

- 落子合法性：测试棋盘外落子与已有棋子位置落子，验证程序是否能有效拦截并提示。

- 落子提示功能：验证高光标记是否精准对应最新落子点，幽灵棋子是否与鼠标位置同步。

- 游戏结束判定：测试五连子与满局场景，验证胜负/平局判定准确性及落子禁止逻辑有效性。

#### 对弈游戏测试

- AI进攻策略：验证AI是否能主动构建必胜棋局，在具备连五条件时直接取胜。

- AI防守策略：验证AI是否能识别并拦截玩家的"活三"等关键棋形。

- AI高级策略：验证AI是否能根据局势灵活采用迷惑性策略争取胜利。

# 五、实验结果与分析

## 1. 实验结果

### 1.1 测试样本识别结果记录表

| 样本编号 | 测试功能 | 操作结果 | 是否符合预期 |  
| :---: | :---: | :---: | :---: |  
| 1 | 非法落子拦截、数组边界稳定性和落子提示 | 图片1和2及其分析 | 符合 |  
| 2 | 游戏结束判定 | 图片3和4及其分析 | 符合 |  
| 3 | AI在必胜局中能否直接取胜并结束游戏 | 图片5及其分析 | 符合 |  
| 4 | AI能否拦截玩家的“活三”或“堵四” | 图片6和7及其分析 | 符合 |  
| 5 | AI能否采取一定的迷惑策略以求取胜 | 图片8及其分析 | 符合 |  
| 6 | AI能否灵活变换策略以求取胜 | 图片9和10及其分析 | 不符合 |  

### 1.2 程序运行截图
*注：下列所有截图中，玩家执黑棋，AI执白棋。*

![图片1](project/report/图片1.png)

【图片1】*玩家（黑棋）尝试在棋盘外（-1，1）处落子，被程序阻止。玩家在（0，0）处落子后，程序仍然正常运行。*  
*AI（白棋）最近一次落子位于（1，1）处，高光提示正常显示。测试结果符合预期。*

![图片2](project/report/图片2.png)

【图片2】*玩家尝试在（1，1）处落子，但此处已有白棋，因此被程序阻止。测试结果符合预期。*  
![图片3](project/report/图片3.png)

【图片3】*玩家连成五子并获胜，界面显示"Player Wins!"字样，且无法继续落子。测试结果符合预期。*  
![图片4](project/report/图片4.png)

【图片4】*AI连成五子并获胜，界面显示"AI Wins!"字样，且无法继续落子。测试结果符合预期。*  
![图片5](project/report/图片5.png)

【图片5】*AI在左上角连成四子后，直接落子于（0，0）处并取胜。测试结果符合预期。*  
![图片6](project/report/图片6.png)

【图片6】*AI成功识别并拦截玩家的“堵四”。测试结果符合预期。*  
![图片7](project/report/图片7.png)

【图片7】*AI成功识别并拦截玩家的“活三”。测试结果符合预期。*  
![图片8](project/report/图片8.png)

【图片8】*AI落子于（6，6）处（即高光提示处），企图在下一轮着子时与左上角的棋子连成“活四”并取胜。对于初等水平的对弈者而言，这一策略不容易被观察到。*  
![图片9](project/report/图片9.png)  
![图片10](project/report/图片10.png)  
【图片9】与【图片10】*在这两张图片中，玩家采用了相同的策略取胜，AI两次以相同的方式失败，这说明AI无法灵活调整策略。测试结果不符合预期。*

## 2. 结果分析

### 2.1 功能有效性分析
程序基础功能测试全部通过，实现了稳定的五子棋人机对战体验。AI可自主构建必胜棋局、拦截玩家关键棋形，具备基础的攻防与迷惑策略执行能力，核心对弈逻辑符合设计预期。
### 2.2 运行效率分析
搜索深度设为3时，AI平均响应时长约1.2秒，可满足基本交互流畅性；当搜索深度提升至4时，AI单次思考时长增至4秒以上，且因`get_best_move()`函数阻塞主循环，导致图形界面出现无响应现象。

### 2.3 系统局限性

- 策略单一性
    - AI的决策输出完全依赖玩家输入，策略固定无随机性。相同对局策略下，AI的应对方式完全一致，无法模拟人类多角度思考，多次重复对局后易被玩家掌握规律（例如相同开局下AI会重复相同失误导致失败）。该问题需通过引入多策略评估函数、实现策略记忆与学习机制，或采用更高级的决策算法解决。

- 搜索深度受限
    - 受算力限制，搜索深度无法超过3。更深的搜索深度会导致决策效率急剧下降，引发界面阻塞，影响用户体验。

# 六、实验总结与心得体会

## 1. 实验总结

### 1.1 核心内容总结

本次实验完成了五子棋人机对战程序的全流程开发，实现了算法逻辑与GUI界面的深度融合。采用模块化编程思想，将系统拆解为评估、搜索、交互三大模块，各模块功能达标、协同高效，整体运行稳定，具备流畅的基础对战体验。

### 1.2 待优化方向

- 功能扩展：新增悔棋、游戏重置、玩家评分统计、AI难度调节等高级交互功能；

- 算法优化：引入多策略评估函数或机器学习记忆机制，提升AI决策的灵活性与智能性；

- 界面优化：优化文本提示的视觉呈现，提升界面精致度与用户体验。

### 1.3 C语言知识点梳理

- 结构体：掌握结构体的定义、初始化及数据封装思想，通过`Move`结构体实现落子信息的统一管理；

- 枚举常量：理解枚举类型对状态描述的直观性优势，通过`GameState`枚举清晰标识回合状态；

- 分文件开发：掌握大型程序的模块化拆分方法，为评估、搜索、交互模块分别设计头文件与源文件（如`search.h`/`search.c`），提升代码可维护性；

- 结构化开发：实践"自上而下"的开发思路，先明确需求与模块划分，再逐一实现模块细节，提升开发效率与代码逻辑性。

## 2. 心得体会

### 2.1 实验收获

本次实验完整经历了"需求分析-设计-实现-测试"的项目开发流程，深刻体会到模块化编程思想的优势。首次实现算法逻辑与GUI界面的结合，掌握了Raylib图形库的基础使用方法与交互逻辑设计技巧。在算法层面，系统学习并实践了博弈树、深度优先搜索、Minimax算法及Alpha-Beta剪枝等技术，深化了C语言核心特性的理解与应用，积累了复杂系统开发的工程实践经验。

### 2.2 困难与反思

实验过程中最大的挑战在于算法思想与代码实现的转化，以及算法模块与GUI模块的接口适配。理论层面理解Minimax算法与博弈树概念后，在落地为五子棋具体逻辑时多次遇到障碍；同时，网上现有算法案例多为通用博弈场景，需结合五子棋规则进行适配改造；此外，算法模块与GUI模块的交互时序设计也需反复调试。这些问题虽耗费大量时间，但通过逐行调试、逻辑拆解与资料查阅最终解决，也让我认识到算法迁移应用与模块协同设计能力的重要性，后续需加强此类专项训练。

### 2.3 后续思考

本程序的核心局限在于AI决策的"确定性"，其决策空间固定且可预测，无法媲美人类的灵活思考。后续计划探索更高级的算法方案突破这一局限，例如引入多评估函数模拟策略多样性，或尝试蒙特卡洛树搜索（MCTS）、神经网络等技术实现AI的自主学习与进化，进一步提升对弈智能性，同时丰富自身在人工智能与博弈算法领域的知识储备。

# 七、附录

本附录包含程序各模块函数的实现逻辑流程图。

## 1. 评估模块函数逻辑

### 评分映射函数`get_pattern_score()`

![](project/report/UntitledDiagram.drawio.png)

### 连子计数函数`evaluate_direction()`

![](project/report/evaluate_direction().drawio.png)

### 局势评分函数`evaluate_board()`

![](project/report/evaluate_board().drawio.png)


## 2. 搜索模块函数逻辑

### 核心搜索算法`minimax_alpha_beta()`

![](project/report/minimax_alpha_beta().drawio.png)

### 最优落子求解`get_best_move()`

![](project/report/get_best_move().drawio.png)

## 3. 交互模块逻辑

### 像素坐标→网格坐标`PositionToCoordinate()`

![](project/report/PositionToCoordinate().drawio.png)

### 网格坐标→像素坐标`CoordinateToPosition()`

![](project/report/CoordinateToPosition().drawio.png)

### 游戏结束判定函数`is_game_over()`

![](project/report/is_game_over.drawio.png)

### GUI层游戏结束判定逻辑

![](project/report/GUI层游戏结束判定.drawio.png)